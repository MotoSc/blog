<?xml-stylesheet type="text/css" href="book.css"?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>闲云野鹤</title>
    <description>一位懒散惯了的前iOS开发者，一个想成为Web开发者的人。可是懒散惯了就是懒散惯了，没有办法学的深入，那就让我在表面好好地趴着吧- =。
</description>
    <link>http://objc.co/</link>
    <atom:link href="http://objc.co/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 13 Jul 2016 17:41:28 +0800</pubDate>
    <lastBuildDate>Wed, 13 Jul 2016 17:41:28 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>读书笔记《代码之髓：编程语言核心概念》 第五章</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;第五章 函数&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;函数的作用&lt;/h2&gt;

&lt;p&gt;函数，即把代码的一部分视作有机整体，然后切分出来并为之命名的涉及机制&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这种机制在不同时期和不同语言中，叫法不同，如事务、程序、子程序等。大部分人习惯称它为“函数”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;便于理解&lt;/h3&gt;

&lt;p&gt;通过把代码分割成多个代码段，把每一个函数是做一个整体并为之命名，这就是函数。代码量比较少的情况下，很容易掌握每一行执行的功能，正割函数的功能。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;便于再利用&lt;/h3&gt;

&lt;p&gt;将数十行、百行代码作为函数，通过简单地调用就能使用它的功能。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;程序中再利用的特征&lt;/h3&gt;

&lt;p&gt;相同操作的事情，只需要实现一次。通过把反复执行的操作封装成函数，进而多次调用，可以确保代码紧凑清晰。&lt;/p&gt;

&lt;p&gt;把相同的代码封装在一起的好处不仅仅在于使用程序更简短，也在于能使阅读程序的人无需反复的读取相同内容的源代码。从冗长的程序中切分反复使用的代码将其封装成一个整体。程序就更容易理解了。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;返回命令&lt;/h2&gt;

&lt;p&gt;返回指令，进入函数前记录当前位置，之后碰到返回语句时又能跳转到记录位置后面的语句。有了返回原来位置的命令，代码再利用就成为了可能。一个程序中有几处执行相同操作时，就可以把这些操作封装在一个地方。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;函数的诞生&lt;/h3&gt;

&lt;p&gt;早在1949年就有反复利用封装命令的技术。但是当时的实现，是通过修改程序跳转命令的目的地来实现的返回原来位置。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;小知识：有返回值的代码段叫函数，没有返回值的叫子程序。代码之髓统称为函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-7&quot;&gt;记录跳转目的地的专用内存&lt;/h3&gt;

&lt;p&gt;在调用函数之前修改返回命令的跳转目的地时，函数调用者必须同时知道跳转目的地在哪里和返回命令在哪里。这个很难实现。假如函数中增加了几行代码，返回命令的位置就会相应地往后挪。这样就不得不修改调用这一函数的全部代码。后来，创建用来事先记录返回目的地的内存空间，并设计能够跳转到该内存空间里记录的地址命令。这样，即时函数调用前不知道返回命令所在地也没关系。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1：将3写入返回目的地内存&lt;/li&gt;
  &lt;li&gt;2：调用函数（跳转至100）&lt;/li&gt;
  &lt;li&gt;3：下一命令&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;100：函数操作&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
  &lt;li&gt;101：返回至返回目的地内存所记录的地址&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;函数命名&lt;/code&gt;，便于理解的字符串取代数值，来表示操作开始时内存的位置。和变量一样。变量的诞生，就是为了用字符串代替数值来表示存储了某个数值的内存位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-8&quot;&gt;栈&lt;/h3&gt;
&lt;p&gt;栈是一种存储了多个值的数据结构，实现最后被存入的值最先被读取。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;随着程序越来越大，把握全局逐渐变得困难。同时，有可能需要多次用到相似的操作。函数就是为了解决这个问题产生的。通过语义上把一块块代码切分出来为之命名，理解这段代码会更加容易。此外，通过在其他地方调用这个函数，实现了再利用。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 13 Jul 2016 17:39:53 +0800</pubDate>
        <link>http://objc.co/2016/07/13/reader-code-spirit_4.html</link>
        <guid isPermaLink="true">http://objc.co/2016/07/13/reader-code-spirit_4.html</guid>
        
        
      </item>
    
      <item>
        <title>test</title>
        <description>
</description>
        <pubDate>Wed, 13 Jul 2016 17:38:59 +0800</pubDate>
        <link>http://objc.co/2016/07/13/test.html</link>
        <guid isPermaLink="true">http://objc.co/2016/07/13/test.html</guid>
        
        
      </item>
    
      <item>
        <title>苹果BigBoss源的安装</title>
        <description>&lt;p&gt;由于不小心，把之前安装过的&lt;code class=&quot;highlighter-rouge&quot;&gt;BigBoss&lt;/code&gt;源删掉了。结果导致有大量的插件不能安装和使用，上网一搜才知道有很多插件是依赖这个源的。本想怎么删就怎么装回来吧。再添加源里输入了&lt;code class=&quot;highlighter-rouge&quot;&gt;http://apt.thebigboss.org/profiles/cydia&lt;/code&gt;,结果提示我版本装不了。。&lt;/p&gt;

&lt;p&gt;后来在威锋上面翻了一下，说是在Cydia中的第一个Tab中，点击更多就行了，里面会有BigBoss。果然，我看了一眼，还真下下来了。
&lt;img src=&quot;http://objc.co/images/2016-07-09/the-big-boss.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Jul 2016 11:30:39 +0800</pubDate>
        <link>http://objc.co/2016/07/09/the-big-boss-repo.html</link>
        <guid isPermaLink="true">http://objc.co/2016/07/09/the-big-boss-repo.html</guid>
        
        
      </item>
    
      <item>
        <title>读书笔记《代码之髓：编程语言核心概念》 第三章</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;第三章 语法的诞生&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;语法就是程序语言设计者规定的解释程序编写方式的一系列规则。&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;运算符优先级，1+2&lt;em&gt;3，早期有计算器计算结果为9，也就是(1+2)&lt;/em&gt;3的执行顺序。而现在大家使用的程序设计语言大多数的计算结果都应该是其。这因为程序设计者制定了乘法优先级高于加法优先级这一规则。因为这和四则运算的法则是一样的。&lt;/li&gt;
  &lt;li&gt;运算顺序，对于9/3/3，是9/(3/3)还是(9/3)/3。大部分语言都是(9/3)/3来计算的。这是因为程序设计者制定了这样的规则：在做结合运算符号除号出现并列的情况下，运算从左开始计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;语法是语言设计者指定的规则&lt;/h3&gt;

&lt;p&gt;语言设计者制定的规则就是语法。语法因语言而异。运算符的存在类型也因语言而异。比如C语言的赋值符号&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;是运算符。但它与普通的加减乘除运算符不同，是又结合运算符。所以代码中X = Y = 1这样的语句，被解释为X = (Y = 1)。不同的是，Python语言的赋值符&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;不是运算符的而是一种句式，在运算式中不能出现。&lt;/p&gt;

&lt;h3 id=&quot;forth&quot;&gt;栈机器和FORTH语言&lt;/h3&gt;

&lt;p&gt;FORTH语言是一种几乎没有语法的语言，其设计者Charles H.Moore说FORTH是最简单的计算机语言。他认为&lt;em&gt;世上所有的程序设计语言都具备一定的可读性，但初次接触某种语言的人常常感到困惑，这是由于他们的语法往往晦涩难懂且变化多端。&lt;/em&gt;而FORTH语言将语法控制到最少的程度缓和了这一问题。&lt;/p&gt;

&lt;p&gt;可以点击这个&lt;a href=&quot;http://nhiro.org/learn_language/FORTH-on-browser.html&quot;&gt;链接&lt;/a&gt;试一下和平时其他语言有什么不同的地方。&lt;/p&gt;

&lt;p&gt;计算的流程  1 2 +  =&amp;gt;  1 + 3    1 2 + 3 * =&amp;gt; (1 + 2) * 3。执行过程FORTH语言使用了被称为栈的数值预存空间。如(1 2 +)，由于先遇到数值1，于是栈中放1。然后遇到数值2，再次将2存进栈。最后遇到+号。这个符号被定义的功能室，从栈中去除前面两个数值，再把其想加的结果存入栈。于是，从栈中把1和2取出来，加法运算后的结果3被放入栈中。&lt;/p&gt;

&lt;h3 id=&quot;lisp&quot;&gt;语法树和LISP语言&lt;/h3&gt;

&lt;p&gt;FORTH语言不需要使用括号或者优先次序就可以表达算顺序。现实中，有的语言总是需要用括号标示完整的意思单元，如1958年的LISP语言,1加2用代码标示为：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;(+ 1 2) //首先是括号，接着是加号命令，用空格分割后，跟上进行相加运算额对象。&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;计算的流程 (* (+ 1 2) 3) =&amp;gt; (1 + 2) * 3
- 1.先做 1与2相加，得到式子A
- 2.将式子A与3相乘
- 3.把A等于1与2的和这个式子带入到过程2中。这样的过程称作为语法树。（式子A就是？）
&lt;img src=&quot;http://objc.co/images/2016-07-08/06.d03z.002.png&quot; alt=&quot;语法树的结构&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;forthlisp&quot;&gt;FORTH和LISP的语法树&lt;/h3&gt;

&lt;p&gt;两者的语法树相同，只是在这个相同的语法树上，按照不同的规则进行遍历，人虽然代码不同，但是所用的树结构相同。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;中缀表达式&lt;/h3&gt;

&lt;p&gt;在FORTH语言中，我们用&lt;code class=&quot;highlighter-rouge&quot;&gt;1 2 +&lt;/code&gt;来表达1加2，运算符放在运算对象的后面。在LISP语言中，1加2表达为&lt;code class=&quot;highlighter-rouge&quot;&gt;+ 1 2&lt;/code&gt;,运算符放在对象的前面。而数学表达式中用&lt;code class=&quot;highlighter-rouge&quot;&gt;1 + 2&lt;/code&gt;来表达，运算符放在运算对象的中间。像这样把运算符放在运算对象之后、之前和之中分别称为：
- 前缀表达式
- 后缀表达式
- 中缀表达式&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;前缀表达式&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;后缀表达式&lt;/code&gt;也被称为波兰表示法和逆波兰表示法，得名与最早研究他们的波兰人。&lt;code class=&quot;highlighter-rouge&quot;&gt;前缀表达式&lt;/code&gt;中的括号并不必须，只是可以在一定场景中避免误解。三种表达式只是表达方法上的约束事项而已。在出现程序设计语言之前，人们尽习惯于使用中缀表达式来书写数学表达式。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;语法解析器&lt;/h3&gt;
&lt;p&gt;语法解析器是把源码作为字符串读入、解析，并建立语法树的过程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;小结
同样语言处理相同的运算，表达式的样子可能大相径庭。但是基本都可以用语法树表示。语言之间的差异就是语法的差异，语法的差异决定了怎么样的代码对应着怎么样的语法树。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 08 Jul 2016 19:19:40 +0800</pubDate>
        <link>http://objc.co/2016/07/08/reader-code-spirit_3.html</link>
        <guid isPermaLink="true">http://objc.co/2016/07/08/reader-code-spirit_3.html</guid>
        
        
      </item>
    
      <item>
        <title>读书笔记《代码之髓：编程语言核心概念》 第二章</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;程序设计语言诞生史&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;可编程语言的发展&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;通过连接电缆，调整电缆的连接方式进行编程。（初代计算机ENIAC）&lt;/li&gt;
  &lt;li&gt;打点的纸带作为数据和逻辑的载体，计算机通过读取纸带上的数据来执行程序。可以通过改变纸带上的数据进行编程。（EDSAC计算机）&lt;/li&gt;
  &lt;li&gt;将公式转化为机器语言的编程语言出现。（FORTRAN）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;经典摘录：FORTRAN的设计者John Backus说道：我的大部分成果源自我的懒惰，因为不喜欢写程序，所以设计出了能轻松编写程序的系统。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;程序设计语言产生的原因&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;原因：为了获得更轻松便捷的体验而编写程序。但轻松不等于偷工减料。&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;懒惰：程序员的三大美德之一&lt;/h4&gt;

&lt;p&gt;优秀程序员的三大美德：&lt;em&gt;懒惰、急躁和傲慢&lt;/em&gt;。（由Perl语言设计者Larry Wall提出的）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;懒惰(Laziness)是一项为了减少总能量支出，而不留余力地努力的素质。为了省下功夫，设计的程序逐步的呗更多人使用。单独回答每个使用者的一位费时费力，于是，程序中开始出现了注释。所以，懒惰是程序员最宝贵的素质。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&quot;section-4&quot;&gt;何为“便捷”&lt;/h6&gt;
&lt;p&gt;在编程语言中，便捷没有一个统一的定义，如PHP写Web服务就很轻松，但是不擅长文字处理。相反Haskell和OCaml这样的ML（Meta-Language）系列，编写处理语言文字的应用就很便捷，但是编写Web服务器就没有PHP使用得那么多了。&lt;/p&gt;

&lt;p&gt;程序设计语言的选用因使用者的目的不同而不同。不同的语言致力于打成不同的目的。如果把实现高速执行而设计的C++语言和为了代码阅读而设计的Python放在一起，说Python的可读性差或者Python的执行速度慢，这样争论的意义并不是很大。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;语言不同，便捷的含义也不同。语言只是实现某一目的的工具，是否适合自己还是要看这门语言能帮助自己发挥多大的能力，而不是看这种语言是否流行，别人能用它发挥多大的能力。选择一门语言，应根据自己的实际情况来选择好的工具。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 08 Jul 2016 15:54:24 +0800</pubDate>
        <link>http://objc.co/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/07/08/reader-code-spirit_2.html</link>
        <guid isPermaLink="true">http://objc.co/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/07/08/reader-code-spirit_2.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>读书笔记《代码之髓：编程语言核心概念》第一章</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;第一章 如何高效地学习语言&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;在比较中学习&lt;/h3&gt;

&lt;p&gt;多学几门语言，在比较中去学习。接触的语言多了之后，可以发现什么地方是两种语言共通的，什么地方是每种独有的。&lt;/p&gt;

&lt;p&gt;语言不同，规则不同&lt;/p&gt;

&lt;p&gt;编程语言中的规则各式各样。这些规则不具有普遍的意义，只是当前场景这样做可能更方便，如&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言和&lt;code class=&quot;highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;语言中的真假值(&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言，&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;为假，其余为真。&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;为真)。&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中有真假值这一数据类型，在做条件判断的时候必须使用这种类型（我的天哪，头回听说。。）。因为0为整形不是真假值类型，如若以&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;为判断条件会发生编译错误。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;总结：
1.多种语言共通的知识才是要点。掌握了这些要点，学习其它语言才会更加轻松。
2.&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;为真、&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;为假、&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;即非真即非假的语言都是存在的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;在历史中学习&lt;/h3&gt;

&lt;p&gt;理解语言设计者的意图，了解语言诞生的历史背景和应用场景。设计者为何创造了这种语言，以及语言的历史变迁。这些知识都能方便我们了解这些语言更适合去做什么，有什么功能适合我们去用它来做什么工作。&lt;/p&gt;

&lt;p&gt;了解语言之后，可以根据自己的需求有选择的学习。不过有时某种语言的热门程度也是大家选择它的主要原因。每种语言都可能有兴盛有衰弱，所以根据比较不同语言、了解语言的历史和变化的原因，培养对不同语言的理解能力是非常重要的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;小结: 学习语言的两种方法:&lt;code class=&quot;highlighter-rouge&quot;&gt;在比较中学习&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;在历史中学习&lt;/code&gt;。其中&lt;code class=&quot;highlighter-rouge&quot;&gt;在比较重学习&lt;/code&gt;不特指某种语言的编程，而是同时比较集中语言。从而掌握知识的重点，哪些知识是共通的，哪些是不同的。  &lt;code class=&quot;highlighter-rouge&quot;&gt;在历史中学习&lt;/code&gt;指的是探寻语言的变化，在变化前存在哪些问题，从而理解语言为何开发出各种新的功能。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 08 Jul 2016 12:12:24 +0800</pubDate>
        <link>http://objc.co/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/07/08/reader-code-spirit_1.html</link>
        <guid isPermaLink="true">http://objc.co/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/07/08/reader-code-spirit_1.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>博客的第一篇文章</title>
        <description>&lt;p&gt;终于把&lt;code class=&quot;highlighter-rouge&quot;&gt;Jekyll&lt;/code&gt;的博客放到了Github上，并绑定上了域名。一路上磕磕碰碰的，完全是一个不小心就设置成功了。&lt;/p&gt;

&lt;p&gt;自打自己做开发以来，就一直想拥有一个自己的博客，主要是做一些IT的技术分享（为了方便找工作。。😄）。当时为了能体现出自己的技术，选择了各种各样的方式来建立自己的博客。从最早的新浪博客，其间依次更换了&lt;a href=&quot;http://blog.csdn.net/grozy_sun/&quot;&gt;CSDN&lt;/a&gt;,&lt;a href=&quot;http://my.oschina.net/9meo&quot;&gt;开源中国&lt;/a&gt;。后来开始使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Hexo&lt;/code&gt;写了一阵子的博客，不过后来为了还是觉得自己写才是真本事，开始尝试用&lt;code class=&quot;highlighter-rouge&quot;&gt;django&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;express&lt;/code&gt;开发博客，不过都因为&lt;code class=&quot;highlighter-rouge&quot;&gt;Nginx&lt;/code&gt;没弄明白，最后一只也没有放到服务器上。。&lt;/p&gt;

&lt;p&gt;现在，我已经告别了自己两年的开发者生涯，成为了一名算是独立开发者了吧。写博客也脱离了初衷，不过也多亏了之前的瞎折腾。虽说学的都没有精通，不过不得不承认多学一些语言之后也有多学的好处，你会抓住学习新语言的重点，会帮助你更快的挺高学习一门新语言的能力。反正现在也不用再出去装了，那就随便选择一个工具来构建这个博客吧。&lt;/p&gt;

&lt;p&gt;从今天开始，我的业余时间可能会越来越多。也可以把更多的时间投入到自己心爱的一个行业上，而不是把他当做工作，只是兴趣。&lt;/p&gt;

&lt;p&gt;最后放上自家爱犬的一张图片
&lt;img src=&quot;http://objc.co/images/2016-07-08/IMG_2484.JPG&quot; alt=&quot;Amy&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;这里只是个开始&lt;/h2&gt;
</description>
        <pubDate>Fri, 08 Jul 2016 00:36:15 +0800</pubDate>
        <link>http://objc.co/%E6%9D%82%E8%B0%88/2016/07/08/the-first-post.html</link>
        <guid isPermaLink="true">http://objc.co/%E6%9D%82%E8%B0%88/2016/07/08/the-first-post.html</guid>
        
        
        <category>杂谈</category>
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Tom&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 07 Jul 2016 17:57:09 +0800</pubDate>
        <link>http://objc.co/jekyll/update/2016/07/07/welcome-to-jekyll.html</link>
        <guid isPermaLink="true">http://objc.co/jekyll/update/2016/07/07/welcome-to-jekyll.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
